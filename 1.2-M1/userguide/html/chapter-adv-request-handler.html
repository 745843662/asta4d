<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>7.&nbsp;Advanced usage of request handler</title><link rel="stylesheet" type="text/css" href="css/manual-multipage.css"><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"><meta name="keywords" content="java, view first, web framework"><link rel="home" href="index.html" title="Asta4D Framework User Guide"><link rel="up" href="asta4d-user-guide.html" title="Part&nbsp;II.&nbsp;User Guide"><link rel="prev" href="chapter-request-handler.html" title="6.&nbsp;Impement request handler and url mapping"><link rel="next" href="chapter-form-flow.html" title="8.&nbsp;Built in form flow"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7.&nbsp;Advanced usage of request handler</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="chapter-request-handler.html">Prev</a>&nbsp;</td><th width="60%" align="center">Part&nbsp;II.&nbsp;User Guide</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="chapter-form-flow.html">Next</a></td></tr></table><hr></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a name="chapter-adv-request-handler"></a>7.&nbsp;Advanced usage of request handler</h2></div></div></div>
  
  
  <p>This chapter is to show how you can make advanced usage of request handler on various situations.</p>
  
  <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="advanced-mvc"></a>7.1.&nbsp;Advanced MVC architecture</h2></div></div></div>
  
  <p>Even we emphasize that Asta4D is a view first framework, it is still compatible with MVC architecture. Further, we would say that 
  Asta4D affords an advanced MVC architecture than traditional MVC frameworks by the view first mechanism.</p>
  
  <p>In the MVC theory, a controller would act as multi roles in a full request process, from wikipedia, it says: <em><span class="remark">"A controller 
  can send commands to the model to update the model's state (e.g., editing a document). It can also send commands to its associated 
  view to change the view's presentation of the model (e.g., by scrolling through a document)."</span></em> But those are not all in most
  situations, we usually have to do more things in a controller such as querying additional assistant data for page rendering.</p>
  
  <p>By traditional MVC architecture, we often have to expand the transaction from the controller layer across to the view layer to combat
  the lazy load issue, which ugly structure is essentially caused by the tangled controller which holds various unrelated duties.</p> 
  
  <p>It is also strange that we have to modify our controller's implementation at every time we change the page appearance at view layer.
  Such situation could not satisfy us since the layers are not uncoupled really.</p>
  
  <p>We would say that the traditional controller is indeed a tangled magic container for most logics, a controller will unfortunately
  be coupled to most layers in the system even our initial purpose of MVC is to uncouple our logics. By contrast, Asta4D allows developers
  to really uncouple all the tangled logics easily. Basically we could split the traditional controller's duty to following parts:</p>
  <div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
      <p>request handler</p>
      <p>Which takes the responsibilities of all the operations with side-effect.</p>
    </li><li class="listitem">
      <p>result matching in url rule</p>
      <p>Which dispatches the request to different views according to the result from request handler</p>
    </li><li class="listitem">
      <p>snippet class</p>
      <p>Which has the responsibility to render data to the page and also holds the obligation of preparing all the necessary data for
      page rendering.</p>
    </li></ul></div>
  
  <p>By above architecture, we could perfectly uncouple our logics by clarifying the obligation of each layer.</p>
  
  <p class="remark"><em><span class="remark">Need sample source ...</span></em></p>

  </div>
  
  
  
  <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="normalize-page-url"></a>7.2.&nbsp;Normalize page url patterns</h2></div></div></div>
  
  <p>Commonly, we would probably have multiple path patterns for the same template file but we would hope our snippet implementation 
  could deal with a unified pattern, which can be simply achieved by a request handler.</p>
  
  <div class="example"><a name="d5e360"></a><p class="title"><b>Example&nbsp;7.1.&nbsp;Normalize page url</b></p><div class="example-contents">
    
    <pre class="programlisting">


rules.add(<span class="hl-string">"/user/name/{name}"</span>).id(<span class="hl-string">"user-page"</span>)

rules.add(<span class="hl-string">"/user/{id}"</span>).id(<span class="hl-string">"user-page"</span>)
     .handler(<span class="hl-keyword">new</span> Object(){
        <em><span class="hl-annotation" style="color: gray">@RequestHandler</span></em>
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> preparePage(Context context, Integer id, String name){
            User user = null;
            <span class="hl-keyword">if</span>(id != null){
                user = queryUserById(id);
            }<span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (name != null){
                user = queryUserByName(name);
            }
            <span class="hl-keyword">if</span>(user != null){
                <span class="hl-comment">//in the snippet class, a @ContextData annotation can by use to retrieve this value by injection</span>
                context.setData(<span class="hl-string">"user-page-condition"</span>, user);
            }
        }
     }).forward(<span class="hl-string">"/user-page.html"</span>);

    </pre>
    <em><span class="remark">Somebody would argue that the above example is apparently a traditional MVC architecture, that is right or wrong. For the most simple situation, if 
    the snippet class will only show the data from entity class User without any extra query, it is true that the above source shows a traditional MVC architecture.
    But for the most situations, the page rendering would require more additional queries, which would be done at the snippet side. Such structure is so far from the
    traditional MVC that we would rather to call it as view first.</span></em>
  </div></div><br class="example-break">
  
  <p>In the above example, we do not cope with the case of user does not exist. The following source shows how we can cope with such situation: </p>
  
  <div class="example"><a name="d5e365"></a><p class="title"><b>Example&nbsp;7.2.&nbsp;Normalize page url and PageNotFoundException</b></p><div class="example-contents">
    
    <pre class="programlisting">


rules.addGlobalForward(PageNotFoundException.<span class="hl-keyword">class</span>, <span class="hl-string">"/template/PageNotFound.html"</span>, <span class="hl-number">404</span>);
rules.addGlobalForward(Throwable.<span class="hl-keyword">class</span>, <span class="hl-string">"/template/UnknownError.html"</span>, <span class="hl-number">500</span>);

rules.add(<span class="hl-string">"/user/name/{name}"</span>).id(<span class="hl-string">"user-page"</span>)

rules.add(<span class="hl-string">"/user/{id}"</span>).id(<span class="hl-string">"user-page"</span>)
     .handler(<span class="hl-keyword">new</span> Object(){
        <em><span class="hl-annotation" style="color: gray">@RequestHandler</span></em>
        <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> preparePage(Context context, Integer id, String name){
            User user = null;
            <span class="hl-keyword">if</span>(id != null){
                user = queryUserById(id);
            }<span class="hl-keyword">else</span> <span class="hl-keyword">if</span> (name != null){
                user = queryUserByName(name);
            }
            <span class="hl-keyword">if</span>(user == null){
                <span class="hl-keyword">throw</span> <span class="hl-keyword">new</span> PageNotFoundException();
            }<span class="hl-keyword">else</span>
                <span class="hl-comment">//in the snippet class, a @ContextData annotation can by use to retrieve this value by injection</span>
                context.setData(<span class="hl-string">"user-page-condition"</span>, user);
            }
        }
     }).forward(<span class="hl-string">"/user-page.html"</span>);

    </pre>
  </div></div><br class="example-break">
  <p>See more details at <a class="xref" href="chapter-best-practice.html#normalize-page-condition" title="9.1.2.&nbsp;Normalize page condition by request handler">Section&nbsp;9.1.2, &#8220;Normalize page condition by request handler&#8221;</a></p>
  </div>
  
  <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="rest-ajax"></a>7.3.&nbsp;Restful and ajax</h2></div></div></div>
  
  <p>For the request which does not require response of html files, such as restful or ajax request, request handler can be used to cope
  with such situation.</p>
  <p>There is a rest() method which does nothing on the current rule by default but can be used as a hint to suggest that the current rule will 
  response customized contents as a restful api. A request handler can return a ContentProvider to supply customized response content. 
  Details of ContenProvider can be found at later chapters, here we only show examples of how to response customized contents.</p>
  
  <div class="example"><a name="d5e374"></a><p class="title"><b>Example&nbsp;7.3.&nbsp;Return header only response</b></p><div class="example-contents">
    
    <pre class="programlisting">

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> UpdateHandler {  
  
    <em><span class="hl-annotation" style="color: gray">@RequestHandler</span></em>  
    <span class="hl-keyword">public</span> ContentProvider doUpdate(String id, String content) {
        <span class="hl-keyword">if</span> (idExists(id)) {
            <span class="hl-keyword">try</span> {
                updateContent(id, content);
                <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> HeaderInfoProvider();
            } <span class="hl-keyword">catch</span> (Exception ex) {
                HeaderInfoProvider header = <span class="hl-keyword">new</span> HeaderInfoProvider(<span class="hl-number">500</span>);
                header.addHeader(<span class="hl-string">"exception"</span>, ex.getMessage());
                <span class="hl-keyword">return</span> header;
            }
        } <span class="hl-keyword">else</span> {
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> HeaderInfoProvider(<span class="hl-number">404</span>);
        }
    }
}  

    </pre>
  </div></div><br class="example-break">
  
  <div class="example"><a name="d5e377"></a><p class="title"><b>Example&nbsp;7.4.&nbsp;Return customized binary data</b></p><div class="example-contents">
    
    <pre class="programlisting">

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> GetHandler {  
  
    <em><span class="hl-annotation" style="color: gray">@RequestHandler</span></em>  
    <span class="hl-keyword">public</span> ContentProvider get(String id) {
        Object data = getContent(id);
        <span class="hl-keyword">if</span> (data == null) {
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> HeaderInfoProvider(<span class="hl-number">404</span>);
        } <span class="hl-keyword">else</span> {
            HeaderInfoProvider header = <span class="hl-keyword">new</span> HeaderInfoProvider();<span class="hl-comment">// default to 200</span>
            header.addHeader(<span class="hl-string">"Content-Type"</span>, <span class="hl-string">"application/json"</span>);

            String json = toJson(data);
            BinaryDataProvider binaryData = <span class="hl-keyword">new</span> BinaryDataProvider(json.getBytes());
            
            <span class="hl-keyword">return</span> <span class="hl-keyword">new</span> SerialProvider(header, binaryData);
        }
    }
}  

    </pre>
  </div></div><br class="example-break">
  
  <p>For json data, there is a more convenience way to response a json string to client. A json() method can be used on 
  rule declaration to ask the framework to convert the returned result from request handler to a json string automatically.
  the above </p>
  
  <div class="example"><a name="d5e381"></a><p class="title"><b>Example&nbsp;7.5.&nbsp;Declare json at rule</b></p><div class="example-contents">
    
    <pre class="programlisting">


<span class="hl-comment">// in rule declaration</span>
rules.add(<span class="hl-string">"/get"</span>).handler(GetHandler.<span class="hl-keyword">class</span>).json();


<span class="hl-comment">//the handler implementation</span>
<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> GetHandler {  
  
    <em><span class="hl-annotation" style="color: gray">@RequestHandler</span></em>  
    <span class="hl-keyword">public</span> Object get(String id) {
        <span class="hl-keyword">return</span> getContent(id);
    }
}  

    </pre>
  </div></div><br class="example-break">
  
  <p class="remark"><em><span class="remark">By default, a rest rule will do nothing on the result of handler and a ContentProvider instance is expected, by contrast,
          there is a built-in json transformer for rules which are declared as json. However, developers can still register a customized
          result transformer for rest rules or even register a customized json transformer to override the default built-in implementation.
          See details at <a class="xref" href="chapter-detail-url-rule.html#UrlMappingRuleInitializer" title="13.1.1.&nbsp;UrlMappingRuleInitializer">Section&nbsp;13.1.1, &#8220;UrlMappingRuleInitializer&#8221;</a></span></em></p>
  
  <p>Further, since a request handler can access HttpServletResponse instance directly, developer can do more complex customization
  on HttpServletResponse instance directly.</p>
  
  <div class="example"><a name="d5e387"></a><p class="title"><b>Example&nbsp;7.6.&nbsp;access HttpServletResponse directly</b></p><div class="example-contents">
    
    <pre class="programlisting">

<span class="hl-keyword">public</span> <span class="hl-keyword">class</span> XXXHandler {  
  
    <em><span class="hl-annotation" style="color: gray">@RequestHandler</span></em>
    <span class="hl-keyword">public</span> <span class="hl-keyword">void</span> handle(HttpServletResponse response) <span class="hl-keyword">throws</span> IOException {
        response.setStatus(<span class="hl-number">200</span>);
        response.addHeader(<span class="hl-string">"xxx"</span>, <span class="hl-string">""</span>);
        response.getOutputStream().write(<span class="hl-string">"OK"</span>.getBytes());
    }
}  

    </pre>
  </div></div><br class="example-break">

  <p>There are two built-in customized request handlers for handler static resouce files and mapping generic path template files.
  See the next section.</p>

  </div>

  <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="handle-static-resource"></a>7.4.&nbsp;Handle static resouce files</h2></div></div></div>
  
  <p>The most simple way to handling static resource files is mapping their path in web.xml then they will be serviced by the servlet container.
  But Asta4D still affords a way to handle them at framework level.</p>
  
  <div class="example"><a name="d5e394"></a><p class="title"><b>Example&nbsp;7.7.&nbsp;handler static files</b></p><div class="example-contents">
    
    <pre class="programlisting">


rules.add(<span class="hl-string">"/js/**/*"</span>).handler(<span class="hl-keyword">new</span> StaticResourceHandler());

rules.add(<span class="hl-string">"/img/**/*"</span>).handler(<span class="hl-keyword">new</span> StaticResourceHandler(<span class="hl-string">"/resource/img"</span>));

rules.add(<span class="hl-string">"/favicon.ico"</span>).handler(<span class="hl-keyword">new</span> StaticResourceHandler(/img/favicon.ico));


    </pre>
  </div></div><br class="example-break">
  
  <p>The wild-card "/**/*" in source path is necessary if you want to mapping all the urls with same path prefix to a certain base folder. The base path
  parameter in constructor of StaticResourceHandler is not necessary. if the base path is not specified, StaticResourceHandler will treat the part before
  the wild-card "/**/*" in source path as the base path.
  </p>
  <p>StaticResourceHandler can be customized by path var configuration or overriding some protected methods by extending. See details in javadoc of 
  StaticResourceHandler.</p>
  
  <div class="example"><a name="d5e399"></a><p class="title"><b>Example&nbsp;7.8.&nbsp;customize StaticResourceHandler</b></p><div class="example-contents">
    
    <pre class="programlisting">


<span class="hl-comment">// by path var</span>

rules.add(<span class="hl-string">"/js/**/*"</span>)
    .var(StaticResourceHandler.VAR_CONTENT_TYPE, <span class="hl-string">"text/javascript"</span>) 
    .handler(StaticResourceHandler.<span class="hl-keyword">class</span>);

<span class="hl-comment">// by overring</span>
rules.add(<span class="hl-string">"/js/**/*"</span>).handler(<span class="hl-keyword">new</span> StaticResourceHandler(){
    <em><span class="hl-annotation" style="color: gray">@Override</span></em>
    <span class="hl-keyword">protected</span> <span class="hl-keyword">long</span> decideCacheTime(String path) {
        <span class="hl-keyword">return</span> <span class="hl-number">24</span> * <span class="hl-number">60</span> * <span class="hl-number">60</span> * <span class="hl-number">1000</span>; <span class="hl-comment">//force cache 24 hours</span>
    }
    
});


    </pre>
    <p>Note that it is not necessary to specify content type for most situations because StaticResourceHandler will guess 
    the content type by file name extension automatically.</p>
  </div></div><br class="example-break">
  
  </div>

  <div class="sect1"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="handle-generic-path"></a>7.5.&nbsp;Handle generic path template files</h2></div></div></div>
  
  <p>Basically Asta4D asks developers to declare the matching relationship between url and template file one by one, but it still allows
  to declare a generic path matching for all files in same folder, which can be achieved by GenericPathTemplateHandler.</p>
  </div>

  <div class="example"><a name="d5e406"></a><p class="title"><b>Example&nbsp;7.9.&nbsp;handler template files in bulk</b></p><div class="example-contents">
    
    <pre class="programlisting">


rules.add(<span class="hl-string">"/pages/**/*"</span>).handler(GenericPathTemplateHandler.<span class="hl-keyword">class</span>);


    </pre>
    <p>As same as the StaticResourceHandler, the wild-card "/**/*" is necessary and the base path parameter of constructor can be ignored.</p>
  </div></div><br class="example-break">


</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="chapter-request-handler.html">Prev</a>&nbsp;</td><td width="20%" align="center"><a accesskey="u" href="asta4d-user-guide.html">Up</a></td><td width="40%" align="right">&nbsp;<a accesskey="n" href="chapter-form-flow.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">6.&nbsp;Impement request handler and url mapping&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;8.&nbsp;Built in form flow</td></tr></table></div></body></html>